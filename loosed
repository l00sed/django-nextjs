#!/bin/bash

#######################################
# GLOBALS
#######################################
export PROJECT_NAME="loosed"
# Use "local" or "prod" for ENV
export ENV="local"
# Use "development" or "production" for NODE_ENV
if [[ "$ENV" == "local" ]]; then
    export NODE_ENV="development"
else
    export NODE_ENV="production"
fi
# Set environment variables to speed up build
export COMPOSE_DOCKER_CLI_BUILD=1
export DOCKER_BUILDKIT=1

# Get current user id/group
export USER_ID=$(id -u)
export GROUP_ID=$(id -g)

#######################################
# FUNCTIONS
#######################################

# Remove build artifacts from project root
clean() {
  (
    # Remove the compose file
    if [ -f "./$ENV.yml" ]; then
      echo "Removing compose file."
      rm "$ENV.yml"
    fi

    if [ -f "./.dockerignore" ]; then
      echo "Removing .dockerignore file."
      rm .dockerignore
    fi
    if [ -f "./backend.Dockerfile" ]; then
      echo "Removing backend Dockerfile."
      rm backend.Dockerfile
    fi
    if [ -f "./frontend.Dockerfile" ]; then
      echo "Removing frontend Dockerfile."
      rm frontend.Dockerfile
    fi
    if [ -f "./nginx.Dockerfile" ]; then
      echo "Removing nginx Dockerfile."
      rm nginx.Dockerfile
    fi
    if [ -f "./db.Dockerfile" ]; then
      echo "Removing db Dockerfile."
      rm db.Dockerfile
    fi
  )
}

cli_backend() {
  (
    clean

    # Pull the local backend Dockerfile into the project root
    cp ".docker/$ENV/backend/backend.Dockerfile" .
    # Grab the local.yml and .dockerignore
    cp ".docker/$ENV/.dockerignore" .
    cp ".docker/$ENV/$ENV.yml" .

    docker compose -f "$ENV.yml" run -it backend /bin/bash
  )
}

cli_frontend() {
  (
    clean

    # Pull the local frontend Dockerfile into the project root
    cp ".docker/$ENV/frontend/frontend.Dockerfile" .
    # Grab the local.yml and .dockerignore
    cp ".docker/$ENV/.dockerignore" .
    cp ".docker/$ENV/$ENV.yml" .

    docker compose -f "$ENV.yml" run -it frontend /bin/bash
  )
}

# Generate LQIPs
gen_lqip() {
  (
    docker exec loosed-backend-1 /bin/bash -c "python manage.py gen_lqip"
  )
}

# Generate a self-signed certificate
generate_cert () {
  (
    echo "Removing existing certificates."
    rm -Rf .docker/local/nginx/certs/loosed.test.*
    echo "Cleaning build files..."
    clean
    echo "Copying local docker compose file to current directory."
    cp .docker/local/local.yml .
    echo "Generating a certificate with OpenSSL."
    docker compose -f local.yml \
      run --rm nginx sh -c "cd /etc/nginx/certs && touch openssl.cnf && cat /etc/ssl/openssl.cnf > openssl.cnf && echo \"\" >> openssl.cnf && echo \"[ SAN ]\" >> openssl.cnf && echo \"subjectAltName=DNS.1:loosed.test,DNS.2:*.loosed.test\" >> openssl.cnf && openssl req -x509 -sha256 -nodes -newkey rsa:4096 -keyout loosed.test.key -out loosed.test.crt -days 3650 -subj \"/CN=*.loosed.test\" -config openssl.cnf -extensions SAN && rm openssl.cnf"
  )
}

# Install certificate
install_cert () {
  if [[ "$OSTYPE" == "darwin"* ]]; then
    sudo security add-trusted-cert -d -r trustRoot -k /Library/Keychains/System.keychain .docker/local/nginx/certs/loosed.test.crt
  elif [[ "$OSTYPE" == "linux-gnu" ]]; then
    sudo ln -s "$(pwd)/.docker/local/nginx/certs/loosed.test.crt" /usr/local/share/ca-certificates/loosed.test.crt
    sudo update-ca-certificates
  else
    echo "Could not install the certificate on the host machine, please do it manually"
  fi
}

# Stop and start the app
restart() {
  (
    stop
    start
  )
}

# Start the containers
run_backend() {
  (
    # Always clean first to make sure we're starting with the right Dockerfile
    clean
    # Pull the local backend Dockerfile into the project root
    cp ".docker/$ENV/backend/backend.Dockerfile" .
    cp ".docker/$ENV/db/db.Dockerfile" .
    cp ".docker/$ENV/.dockerignore" .
    cp ".docker/$ENV/$ENV.yml" .

    docker compose -p "loosed" \
      -f "$ENV.yml" \
      --verbose run backend /bin/bash
  )
}

# Backend Docker container's command script
start_backend() {
  (
    # Activate the virtual environment (where Django is installed)
    . ./bin/activate
    # Run Django app prep
    python manage.py collectstatic --no-input
    # Migrate database tables
    python manage.py makemigrations
    python manage.py migrate
    # Import pages
    python manage.py sync_mdx
    # Run Gunicorn WSGI client
    # WARN: (`--reload` argument not recommended for production)
    gunicorn backend.wsgi:application --bind :8000 --reload
  )
}

# Start the containers
start() {
  (
    # Always clean first to make sure we're starting with the right Dockerfile
    clean
    # Pull the local backend Dockerfile into the project root
    cp ".docker/$ENV/backend/backend.Dockerfile" .
    # Pull the local frontend Dockerfile into the project root
    cp ".docker/$ENV/frontend/frontend.Dockerfile" .
    # Pull the local nginx Dockerfile into the project root
    cp ".docker/$ENV/nginx/nginx.Dockerfile" .
    # Grab the local.yml and .dockerignore
    cp ".docker/$ENV/.dockerignore" .
    cp ".docker/$ENV/$ENV.yml" .

    # Sync MDX before starting up
    sync_mdx

    docker compose -p "loosed" \
      -f "$ENV.yml" \
      --verbose up
  )
}

# Stop the containers
stop() {
  (
    echo "Cleaning build files."
    # Always clean first to make sure we're starting with the right Dockerfile
    clean
    echo "Copying docker compose file to the current directory."
    cp ".docker/$ENV/$ENV.yml" .
    echo "Killing and removing project containers."
    docker compose -f "$ENV.yml" down --remove-orphans
    echo "Again, cleaning up build files."
    clean
  )
}

# Build the containers
build() {
  (
    # Always clean first to make sure we're starting with the right Dockerfile
    clean

    # Pull the local backend Dockerfile into the project root
    cp ".docker/$ENV/backend/backend.Dockerfile" .
    # Pull the local frontend Dockerfile into the project root
    cp ".docker/$ENV/frontend/frontend.Dockerfile" .
    # Pull the local nginx Dockerfile into the project root
    cp ".docker/$ENV/nginx/nginx.Dockerfile" .
    ## Pull the local db Dockerfile into the project root
    cp ".docker/$ENV/db/db.Dockerfile" .
    # Grab the local.yml and .dockerignore
    cp ".docker/$ENV/.dockerignore" .
    cp ".docker/$ENV/$ENV.yml" .

    if [ -z "$2" ]; then
      if [[ "$2" -eq "no-cache" ]]; then
        # Remove existing build cache
        docker buildx prune -af
        docker builder prune -af
        # Run docker compose to build the image with either local/production Dockerfiles
        docker compose -p "loosed" \
          -f "$ENV.yml" build \
          --progress plain \
          --build-arg USER_ID=${USER_ID} \
          --build-arg GROUP_ID=${GROUP_ID} \
          --no-cache
      fi
    else
      # Run docker compose to build the image with either local/production Dockerfiles
      docker compose -p "loosed" \
        -f "$ENV.yml" build \
        --progress plain \
        --build-arg USER_ID=${USER_ID} \
        --build-arg GROUP_ID=${GROUP_ID}
    fi

    clean
  )
}

# Sync MDX
sync_mdx() {
  (
    docker exec loosed-backend-1 /bin/bash -c "python manage.py sync_mdx"
  )
}

#######################################
# MENU
#######################################

case "$1" in
  build)
    build
    ;;
  clean)
    clean
    ;;
  cli_backend)
    cli_backend
    ;;
  cli_frontend)
    cli_frontend
    ;;
  gen_lqip)
    gen_lqip
    ;;
  generate_cert)
    generate_cert
    ;;
  install_cert)
    install_cert
    ;;
  restart)
    restart
    ;;
  run_backend)
    run_backend
    ;;
  start)
    start
    ;;
  start_backend)
    start_backend
    ;;
  stop)
    stop
    ;;
  sync_mdx)
    sync_mdx
    ;;
  *)
    cat << EOF

Command line interface for Docker-based Web application environment.

Usage:
  loosed <command> [options] [env]

Available commands:
  build ..................................... Build the containers' images (can use "--no-cache" option)
  clean ..................................... Remove build artifacts
  cli_backend ............................... Start a command prompt for the backend image
  cli_frontend .............................. Start a command prompt for the frontend image
  gen_lqip .................................. Generate LQIPs in the backend
  generate_cert ............................. Generate an SSL certificate (local only, env ignored)
  install_cert .............................. Install cert on host machine (local only, env ignored)
  restart ................................... Restart the containers
  start_backend ............................. Run backend (Django) in container
  start ..................................... Start the containers
  stop ...................................... Stop the containers
  sync_mdx .................................. Sync the MDX files

Available environments:
  local ..................................... Manipulate development environment
  prod ...................................... Manipulate production environment

EOF
  exit
  ;;
esac
