#!/bin/bash

#######################################
# GLOBALS
#######################################
export PROJECT_NAME="loosed"
# Use "local" or "prod" for ENV
export ENV="local"
# Set environment variables to speed up build
export COMPOSE_DOCKER_CLI_BUILD=1
export DOCKER_BUILDKIT=1

# Get current user id/group
UID_CMD=$(id -u)
export USER_ID=$UID_CMD
GID_CMD=$(id -g)
export GROUP_ID=$GID_CMD

#######################################
# FUNCTIONS
#######################################

backend_cli() {
  (
    clean

    # Pull the local backend Dockerfile into the project root
    cp ".docker/$ENV/backend/backend.Dockerfile" .
    # Grab the local.yml and .dockerignore
    cp ".docker/$ENV/.dockerignore" .
    cp ".docker/$ENV/$ENV.yml" .

    docker compose -f "$ENV.yml" run -it backend /bin/bash
  )
}

# Backend Docker container's command script
backend_dev() {
  backend_prepare "dev"
}

backend_export() {
  python manage.py dumpdata | jq > "db_$(date +%N).json"
}

backend_import() {
  python manage.py loaddata "$2"
}

backend_prepare() {
  (
    # Activate the virtual environment (where Django is installed)
    . ./bin/activate
    # Run Django app prep
    python manage.py collectstatic --no-input
    # Migrate database tables
    python manage.py makemigrations
    python manage.py migrate
    # Import pages
    python manage.py sync_mdx
    # Run Gunicorn WSGI client
    # gunicorn backend.wsgi:application --bind :8000 --reload
    # Run Gunicorn ASGI client
    if [ "$#" == 1 ]; then
      if [[ "$1" == "dev" ]]; then
        # WARN: `--reload` argument should not be used in production
        # Gunicorn's hot-reload will not work with Uvicorn workers (using ASGI),
        # but you can switch to WSGI tempomrarily for hot-reload behavior to work.
        # Just make sure to run ASGI in production (or in development).
        # In order to use or test Python async functionality, switch back to ASGI.
        #   gunicorn backend.wsgi:application --bind :8000 --reload
        gunicorn backend.asgi:application --bind :8000 -k uvicorn.workers.UvicornWorker
      fi
    else
      gunicorn backend.asgi:application --bind :8000 -k uvicorn.workers.UvicornWorker
    fi
  )
}

# Start the containers
backend_run() {
  (
    # Always clean first to make sure we're starting with the right Dockerfile
    clean
    # Pull the local backend Dockerfile into the project root
    cp ".docker/$ENV/backend/backend.Dockerfile" .
    cp ".docker/$ENV/db/db.Dockerfile" .
    cp ".docker/$ENV/.dockerignore" .
    cp ".docker/$ENV/$ENV.yml" .

    docker compose -p "loosed" \
      -f "$ENV.yml" \
      --verbose run backend /bin/bash
  )
}

# Backend Docker container's command script
backend_start() {
  backend_prepare
}

# Build the Docker images
build() {
  (
    # Always clean first to make sure we're starting with the right Dockerfile
    clean

    # Pull the local backend Dockerfile into the project root
    cp ".docker/$ENV/backend/backend.Dockerfile" .
    # Pull the local frontend Dockerfile into the project root
    cp ".docker/$ENV/frontend/frontend.Dockerfile" .
    # Pull the local nginx Dockerfile into the project root
    cp ".docker/$ENV/nginx/nginx.Dockerfile" .
    ## Pull the local db Dockerfile into the project root
    cp ".docker/$ENV/db/db.Dockerfile" .
    # Grab the local.yml and .dockerignore
    cp ".docker/$ENV/.dockerignore" .
    cp ".docker/$ENV/$ENV.yml" .

    if [ $# -eq 1 ]; then
      # Run docker compose to build the image with either local/production Dockerfiles
      docker compose -p "loosed" \
        -f "$ENV.yml" build \
        --progress plain \
        --build-arg USER_ID="$USER_ID" \
        --build-arg GROUP_ID="$GROUP_ID"
    fi

    if [ $# -eq 2 ]; then
      if [[ "$2" == "no-cache" ]]; then
        # Remove existing build cache
        docker buildx prune -af
        docker builder prune -af
        # Run docker compose to build the image with either local/production Dockerfiles
        docker compose -p "loosed" \
          -f "$ENV.yml" build \
          --progress plain \
          --build-arg USER_ID="$USER_ID" \
          --build-arg GROUP_ID="$GROUP_ID" \
          --no-cache
      fi
    fi

    clean
  )
}

# Use OpenSSL to generate an SSL certificate
build_cert() {
  (
    cd /etc/nginx/certs || exit
    # Build OpenSSL configuration file
    touch openssl.cnf
    cat /etc/ssl/openssl.cnf > openssl.cnf
    {
      printf "\n"; \
      printf "[SAN]\n"; \
      printf "subjectAltName=DNS.1:loosed.local,DNS.2:*.loosed.local";
    } >> openssl.cnf
    # Generate OpenSSL keys
    openssl req -x509 -sha256 -nodes -newkey rsa:4096 -keyout loosed.local.key -out loosed.local.crt -days 3650 -subj "/CN=*.loosed.local" -config openssl.cnf -extensions SAN
    rm openssl.cnf
  )
}

# Remove build artifacts from project root
clean() {
  (
    # Remove the compose file
    if [ -f "./$ENV.yml" ]; then
      echo "Removing compose file."
      rm "$ENV.yml"
    fi

    if [ -f "./.dockerignore" ]; then
      echo "Removing .dockerignore file."
      rm .dockerignore
    fi
    if [ -f "./backend.Dockerfile" ]; then
      echo "Removing backend Dockerfile."
      rm backend.Dockerfile
    fi
    if [ -f "./frontend.Dockerfile" ]; then
      echo "Removing frontend Dockerfile."
      rm frontend.Dockerfile
    fi
    if [ -f "./nginx.Dockerfile" ]; then
      echo "Removing nginx Dockerfile."
      rm nginx.Dockerfile
    fi
    if [ -f "./db.Dockerfile" ]; then
      echo "Removing db Dockerfile."
      rm db.Dockerfile
    fi
  )
}

frontend_cli() {
  (
    clean

    # Pull the local frontend Dockerfile into the project root
    cp ".docker/$ENV/frontend/frontend.Dockerfile" .
    # Grab the local.yml and .dockerignore
    cp ".docker/$ENV/.dockerignore" .
    cp ".docker/$ENV/$ENV.yml" .

    docker compose -f "$ENV.yml" run -it frontend /bin/bash
  )
}

# Frontend Docker container's dev command script
frontend_dev() {
  export NODE_ENV="development"; \
  npm run dev
}

# Frontend Docker container's command script
frontend_start() {
  export NODE_ENV="production"; \
  npm run build; \
  npm run start
}

# Generate LQIPs
gen_lqip() {
  docker exec loosed-backend-1 /bin/bash -c "python manage.py gen_lqip"
}

# Generate a self-signed certificate
generate_cert () {
  (
    echo "Removing existing certificates."
    rm -Rf .docker/local/nginx/certs/loosed.local.*
    echo "Cleaning build files..."
    clean
    echo "Copying local docker compose file to current directory."
    cp .docker/local/local.yml .
    cp .docker/local/nginx/nginx.Dockerfile .
    # Isolate nginx service, and remove dependency services
    yq -y '.services.nginx |= del(.depends_on)' < local.yml
    yq -y '.services |= del(.db, .backend, .frontend, .redis)' < local.yml
    echo "Generating a certificate with OpenSSL."
    docker compose -f local.yml \
      run --rm nginx sh -c "/etc/nginx/./loosed build_cert"
  )
}

# Install certificate
install_cert () {
  if [[ "$OSTYPE" == "darwin"* ]]; then
    sudo security add-trusted-cert -d -r trustRoot -k /Library/Keychains/System.keychain .docker/local/nginx/certs/loosed.local.crt
  elif [[ "$OSTYPE" == "linux-gnu" ]]; then
    sudo ln -s "$(pwd)/.docker/local/nginx/certs/loosed.local.crt" /usr/local/share/ca-certificates/loosed.local.crt
    sudo update-ca-certificates
  else
    echo "Could not install the certificate on the host machine, please do it manually"
  fi
}

# Stop and start the app
restart() {
  (
    stop
    if [[ "$NODE_ENV" == "development" ]]; then
      start "dev"
    else
      start
    fi
  )
}

# Start the containers
start() {
  (
    # Always clean first to make sure we're starting with the right Dockerfile
    clean
    # Pull the local backend Dockerfile into the project root
    cp ".docker/$ENV/backend/backend.Dockerfile" .
    # Pull the local frontend Dockerfile into the project root
    cp ".docker/$ENV/frontend/frontend.Dockerfile" .
    # Pull the local nginx Dockerfile into the project root
    cp ".docker/$ENV/nginx/nginx.Dockerfile" .
    # Grab the local.yml and .dockerignore
    cp ".docker/$ENV/.dockerignore" .
    cp ".docker/$ENV/$ENV.yml" .

    # Sync MDX before starting up
    sync_mdx
  )

  if [ "$#" == 2 ]; then
    if [[ "$2" = "dev" ]]; then
      echo "Running in development mode."; \
      export FRONTEND_ACTION="frontend_dev"; \
      export BACKEND_ACTION="backend_dev";
    fi
  else
    echo "Running production application."; \
    export FRONTEND_ACTION="frontend_start"; \
    export BACKEND_ACTION="backend_start";
  fi

  # Run docker compose to build the image with either local/production Dockerfiles
  docker compose -p "loosed" \
    -f "$ENV.yml" \
    --verbose up
}

# Stop the containers
stop() {
  (
    echo "Cleaning build files."
    # Always clean first to make sure we're starting with the right Dockerfile
    clean
    echo "Copying docker compose file to the current directory."
    cp ".docker/$ENV/$ENV.yml" .
    echo "Killing and removing project containers."
    docker compose -f "$ENV.yml" down --remove-orphans
    echo "Again, cleaning up build files."
    clean
  )
}

# Sync MDX
sync_mdx() {
  docker exec loosed-backend-1 /bin/bash -c "python manage.py sync_mdx"
}

#######################################
# MENU
#######################################

case "$1" in
  backend_cli)
    backend_cli
    ;;
  backend_dev)
    backend_dev
    ;;
  backend_export)
    backend_export
    ;;
  backend_import)
    backend_import "$@"
    ;;
  backend_prepare)
    backend_prepare
    ;;
  backend_run)
    backend_run
    ;;
  backend_start)
    backend_start
    ;;
  build)
    build "$@"
    ;;
  build_cert)
    build_cert
    ;;
  clean)
    clean
    ;;
  frontend_cli)
    frontend_cli
    ;;
  frontend_dev)
    frontend_dev
    ;;
  frontend_start)
    frontend_start
    ;;
  gen_lqip)
    gen_lqip
    ;;
  generate_cert)
    generate_cert
    ;;
  install_cert)
    install_cert
    ;;
  restart)
    restart
    ;;
  start)
    start "$@"
    ;;
  stop)
    stop
    ;;
  sync_mdx)
    sync_mdx
    ;;
  *)
    cat << EOF

Command line interface for Docker-based Web application environment.

Usage:
  loosed <command> [options] [env]

Available commands:
  backend_cli ............................... Start a command prompt for the backend image
  backend_dev ............................... Start Django backend with "--reload" flag
  backend_export ............................ Use Django "dumpdata" to export database
  backend_import ............................ Use Django "loaddata" to import json
  backend_prepare ........................... Internal, use "dev" (backend_prepare "dev") to run backend_dev
  backend_run ............................... Run only the backend container
  backend_start ............................. Start Django backend without "--reload" flag (production mode)
  build_cert ................................ Generate an OpenSSL certificate
  build ..................................... Build the containers' images (can use "--no-cache" option)
  clean ..................................... Remove build artifacts
  frontend_cli .............................. Start a command prompt for the frontend image
  frontend_dev .............................. Start Next application in development mode
  frontend_start ............................ Start Next application in production mode
  gen_lqip .................................. Generate LQIPs in the backend
  generate_cert ............................. Generate an SSL certificate (local only, env ignored)
  install_cert .............................. Install cert on host machine (local only, env ignored)
  restart ................................... Restart the containers
  start [dev] ............................... Start the containers, use "dev" argument to run in development
  stop ...................................... Stop the containers
  sync_mdx .................................. Sync the MDX files

Available environments:
  local ..................................... Manipulate development environment
  prod ...................................... Manipulate production environment

EOF
  exit
  ;;
esac
