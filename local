#!/bin/bash

#######################################
# FUNCTIONS
#######################################

# Remove build artifacts from project root
clean() {
  (
    if [ -f "./local.yml" ]; then
      echo "Removing compose file."
      rm local.yml
    fi
    if [ -f "./backend.Dockerfile" ]; then
      echo "Removing backend Dockerfile."
      rm backend.Dockerfile
    fi
    if [ -f "./frontend.Dockerfile" ]; then
      echo "Removing frontend Dockerfile."
      rm frontend.Dockerfile
    fi
  )
}

# Generate a self-signed certificate
generate_cert () {
  (
    echo "Removing existing certificates."
    rm -Rf .docker/local/nginx/certs/loosed.test.*
    echo "Cleaning build files..."
    clean
    echo "Copying local docker compose file to current directory."
    cp .docker/local/local.yml .
    echo "Generating a certificate with OpenSSL."
    docker compose -f local.yml run --rm nginx sh -c "cd /etc/nginx/certs && touch openssl.cnf && cat /etc/ssl/openssl.cnf > openssl.cnf && echo \"\" >> openssl.cnf && echo \"[ SAN ]\" >> openssl.cnf && echo \"subjectAltName=DNS.1:loosed.test,DNS.2:*.loosed.test\" >> openssl.cnf && openssl req -x509 -sha256 -nodes -newkey rsa:4096 -keyout loosed.test.key -out loosed.test.crt -days 3650 -subj \"/CN=*.loosed.test\" -config openssl.cnf -extensions SAN && rm openssl.cnf"
  )
}

# Install certificate
install_cert () {
  if [[ "$OSTYPE" == "darwin"* ]]; then
    sudo security add-trusted-cert -d -r trustRoot -k /Library/Keychains/System.keychain .docker/local/nginx/certs/loosed.test.crt
  elif [[ "$OSTYPE" == "linux-gnu" ]]; then
    sudo ln -s "$(pwd)/.docker/local/nginx/certs/loosed.test.crt" /usr/local/share/ca-certificates/loosed.test.crt
    sudo update-ca-certificates
  else
    echo "Could not install the certificate on the host machine, please do it manually"
  fi
}

# Stop and start the app
restart() {
  (
    stop
    start
  )
}

# Backend Docker container's command script
run_backend() {
  (
    # change into the backend directory
    cd /app/backend
    # Activate the virtual environment (where Django is installed)
    . ./bin/activate
    # Run Django app prep
    python manage.py collectstatic --no-input
    # Run Gunicorn WSGI client
    # WARN: (`--reload` argument not recommended for production)
    gunicorn backend.wsgi:application --bind :8000 --reload
  )
}

run_frontend() {
  (
    cd /home/nextjs
    npm run dev
  )
}

# Start the containers
start() {
  (
    # Always clean first to make sure we're starting with the right Dockerfile
    clean
    cp .docker/local/local.yml .
    export USER_ID=$(id -u)
    export GROUP_ID=$(id -g)
    docker compose -f local.yml --verbose up
  )
}

# Stop the containers
stop() {
  (
    echo "Cleaning build files."
    # Always clean first to make sure we're starting with the right Dockerfile
    clean
    echo "Copying docker compose file to the current directory."
    cp .docker/local/local.yml .
    echo "Killing and removing project containers."
    docker compose -f local.yml down
    echo "Again, cleaning up build files."
    clean
  )
}

# Build the containers
build() {
  (
    # Always clean first to make sure we're starting with the right Dockerfile
    clean
    # Pull the local backend Dockerfile into the project root
    cp .docker/local/backend/backend.Dockerfile .
    # Pull the local frontend Dockerfile into the project root
    cp .docker/local/frontend/frontend.Dockerfile .
    # Pull the local nginx Dockerfile into the project root
    cp .docker/local/nginx/nginx.Dockerfile .
    # Grab the local.yml
    cp .docker/local/local.yml .
    export USER_ID=$(id -u)
    export GROUP_ID=$(id -g)
    export COMPOSE_DOCKER_CLI_BUILD=1
    export DOCKER_BUILDKIT=1
    # Run docker compose to build the image with the local Dockerfile
    docker compose -f local.yml build \
      --progress plain \
      --build-arg USER_ID=${USER_ID} \
      --build-arg GROUP_ID=${GROUP_ID} \
      --no-cache
    clean
  )
}

#######################################
# MENU
#######################################

case "$1" in
  build)
    build
    ;;
  clean)
    clean
    ;;
  generate_cert)
    generate_cert
    ;;
  install_cert)
    install_cert
    ;;
  restart)
    restart
    ;;
  run_backend)
    run_backend
    ;;
  run_frontend)
    run_frontend
    ;;
  start)
    start
    ;;
  stop)
    stop
    ;;
  *)
    cat << EOF

Command line interface for Docker-based Web application environment.

Usage:
  local <command> [options] [arguments]

Available commands:
  build ..................................... Build the containers' images
  clean ..................................... Remove build artifacts
  generate_cert ............................. Generate an SSL certificate
  install_cert .............................. Install cert on host machine
  restart ................................... Restart the containers
  run_backend ............................... Run backend (Django) in container
  run_frontend .............................. Run frontend (React) in container
  start ..................................... Start the containers
  stop ...................................... Stop the containers

EOF
  exit
  ;;
esac
